{
  "id": "594b898169c1d644f900002e",
  "name": "RoboScript #4 - RS3 Patterns to the Rescue",
  "slug": "roboscript-number-4-rs3-patterns-to-the-rescue",
  "category": "algorithms",
  "publishedAt": "2017-06-23T10:23:46Z",
  "approvedAt": null,
  "languages": [
    "php",
    "javascript"
  ],
  "url": "https://www.codewars.com/kata/roboscript-number-4-rs3-patterns-to-the-rescue",
  "rank": {
    "id": null,
    "name": null,
    "color": null
  },
  "createdAt": "2017-06-22T09:10:25Z",
  "createdBy": {
    "username": "donaldsebleung",
    "url": "https://www.codewars.com/users/donaldsebleung"
  },
  "description": "# RoboScript #4 - RS3 Patterns to the Rescue\n\n## Disclaimer\n\nThe story presented in this Kata Series is purely fictional; any resemblance to actual programming languages, products, organisations or people should be treated as purely coincidental.\n\n## About this Kata Series\n\nThis Kata Series is based on a fictional story about a computer scientist and engineer who owns a firm that sells a toy robot called MyRobot which can interpret its own (esoteric) programming language called RoboScript.  Naturally, this Kata Series deals with the software side of things (I'm afraid Codewars cannot test your ability to build a physical robot!).\n\n## Story\n\nEver since you released [RS2](https://www.codewars.com/kata/58738d518ec3b4bf95000192) to the market, there have been much fewer complaints from RoboScript developers about the inefficiency of the language and the popularity of your programming language has continuously soared.  It has even gained so much attention that Zachary Mikowski, the CEO of the world-famous Doodle search engine, has contacted you to try out your product!  Initially, when you explain the RoboScript (RS2) syntax to him, he looks satisfied, but then he soon finds a major loophole in the efficiency of the RS2 language and brings forth the following program:\n\n```\n(F2LF2R)2FRF4L(F2LF2R)2(FRFL)4(F2LF2R)2\n```\n\nAs you can see from the program above, the movement sequence `(F2LF2R)2` has to be rewritten every time and no amount of RS2 syntax can simplify it because the movement sequences in between are different each time (`FRF4L` and `(FRFL)4`).  If only RoboScript had a movement sequence reuse feature that makes writing programs like these less repetitive ... \n\n## Task\n\nDefine and implement the RS3 specification whose syntax is a superset of [RS2](https://www.codewars.com/kata/58738d518ec3b4bf95000192) (and RS1) syntax.  Your interpreter should be named `execute()`/`execute` and accept exactly 1 argument `$code`/`code`, the RoboScript code to be executed.\n\n### Patterns - The New Feature\n\nTo solve the problem outlined in the Story above, you have decided to introduce a new syntax feature to RS3 called the \"pattern\".  The \"pattern\" as defined in RS3 behaves rather like a primitive version of functions/methods in other programming languages - it allows the programmer to define and name (to a certain extent) a certain sequence of movements which can be easily referenced and reused later instead of rewriting the whole thing.\n\nThe basic syntax for defining a pattern is as follows:\n\n```\np(n)<CODE_HERE>q\n```\n\nWhere:\n\n- `p` is a \"keyword\" that declares the beginning of a pattern definition (much like the `function` keyword in JavaScript or the `def` keyword in Python)\n- `(n)` is any non-negative integer (without the round brackets) which acts as a unique identifier for the pattern (much like a function/method name)\n- `<CODE_HERE>` is any valid RoboScript code (without the angled brackets)\n- `q` is a \"keyword\" that marks the end of a pattern definition (like the `end` keyword in Ruby)\n\nFor example, if I want to define `(F2LF2R)2` as a pattern and reuse it later in my code:\n\n```\np0(F2LF2R)2q\n```\n\nIt can also be rewritten as below since `(n)` only serves as an identifier and its value doesn't matter:\n\n```\np312(F2LF2R)2q\n```\n\nLike function/method definitions in other languages, merely defining a pattern (or patterns) in RS3 should cause no side effects, so:\n\n```php\nexecute('p0(F2LF2R)2q'); // => '*'\nexecute('p312(F2LF2R)2q'); // => '*'\n```\n```javascript\nexecute('p0(F2LF2R)2q'); // => '*'\nexecute('p312(F2LF2R)2q'); // => '*'\n```\n\nTo invoke a pattern (i.e. make the MyRobot move according to the movement sequences defined inside the pattern), a capital `P` followed by the pattern identifier `(n)` is used:\n\n```\nP0\n```\n\n(or `P312`, depending on which example you are using)\n\nSo:\n\n```php\nexecute('p0(F2LF2R)2qP0'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\nexecute('p312(F2LF2R)2qP312'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\n```\n```javascript\nexecute('p0(F2LF2R)2qP0'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\nexecute('p312(F2LF2R)2qP312'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\n```\n\n### Additional Rules for parsing RS3\n\nIt doesn't matter whether the invocation of the pattern or the pattern definition comes first - pattern definitions should **always** be parsed first, so:\n\n```php\nexecute('P0p0(F2LF2R)2q'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\nexecute('P312p312(F2LF2R)2q'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\n```\n```javascript\nexecute('P0p0(F2LF2R)2q'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\nexecute('P312p312(F2LF2R)2q'); // => \"    *\\r\\n    *\\r\\n  ***\\r\\n  *  \\r\\n***  \"\n```\n\nOf course, RoboScript code can occur anywhere before and/or after a pattern definition/invocation, so:\n\n```php\nexecute('F3P0Lp0(F2LF2R)2qF2'); // => \"       *\\r\\n       *\\r\\n       *\\r\\n       *\\r\\n     ***\\r\\n     *  \\r\\n******  \"\n```\n```javascript\nexecute('F3P0Lp0(F2LF2R)2qF2'); // => \"       *\\r\\n       *\\r\\n       *\\r\\n       *\\r\\n     ***\\r\\n     *  \\r\\n******  \"\n```\n\nMuch like a function/definition can be invoked multiple times in other languages, a pattern should also be able to be invoked multiple times in RS3.  So:\n\n```php\nexecute('(P0)2p0F2LF2RqP0'); // => \"      *\\r\\n      *\\r\\n    ***\\r\\n    *  \\r\\n  ***  \\r\\n  *    \\r\\n***    \"\n```\n```javascript\nexecute('(P0)2p0F2LF2RqP0'); // => \"      *\\r\\n      *\\r\\n    ***\\r\\n    *  \\r\\n  ***  \\r\\n  *    \\r\\n***    \"\n```\n\nIf a pattern is invoked which does not exist, your interpreter should `throw`.  This could be anything and will not be tested, but *ideally* it should provide a useful message which describes the error in detail.  **In PHP this must be an instance of** `ParseError`.\n\n```php\nexecute('p0(F2LF2R)2qP1'); // throws ParseError\nexecute('P0p312(F2LF2R)2q'); // throws ParseError\nexecute('P312'); // throws ParseError\n```\n```javascript\nexecute('p0(F2LF2R)2qP1'); // throws an error\nexecute('P0p312(F2LF2R)2q'); // throws an error\nexecute('P312'); // throws an error\n```\n\nMuch like any good programming language will allow you to define an unlimited number of functions/methods, your RS3 interpreter should also allow the user to define a virtually unlimited number of patterns.  A pattern definition should be able to invoke other patterns if required.  If the same pattern (i.e. both containing the same identifier `(n)`) is defined more than once, your interpreter should `throw` (again, anything).  **In PHP this error must again be an instance of** `ParseError`.\n\n```php\nexecute('P1P2p1F2Lqp2F2RqP2P1'); // => \"  ***\\r\\n  * *\\r\\n*** *\"\nexecute('p1F2Lqp2F2Rqp3P1(P2)2P1q(P3)3'); // => \"  *** *** ***\\r\\n  * * * * * *\\r\\n*** *** *** *\"\nexecute('p1F2Lqp1(F3LF4R)5qp2F2Rqp3P1(P2)2P1q(P3)3'); // throws ParseError\n```\n```javascript\nexecute('P1P2p1F2Lqp2F2RqP2P1'); // => \"  ***\\r\\n  * *\\r\\n*** *\"\nexecute('p1F2Lqp2F2Rqp3P1(P2)2P1q(P3)3'); // => \"  *** *** ***\\r\\n  * * * * * *\\r\\n*** *** *** *\"\nexecute('p1F2Lqp1(F3LF4R)5qp2F2Rqp3P1(P2)2P1q(P3)3'); // throws an error\n```\n\nFurthermore, your interpreter should be able to detect (potentially) infinite recursion, including mutual recursion.  Instead of just getting stuck in an infinite loop and timing out, your interpreter should `throw` (yes, anything again) when the \"stack\" (or just the total number of pattern invocations) exceeds a particular very high (but sensible) threshold.  **In PHP, the thrown error once again must be an instance of** `ParseError`.\n\n```php\nexecute('p1F2RP1F2LqP1'); // throws ParseError\nexecute('p1F2LP2qp2F2RP1qP1'); // throws ParseError\n```\n```javascript\nexecute('p1F2RP1F2LqP1'); // throws an error\nexecute('p1F2LP2qp2F2RP1qP1'); // throws an error\n```\n\nFor the sake of simplicity, you may assume that all programs passed into your interpreter contains valid syntax and that pattern definitions will never be empty.  Furthermore, nesting pattern definitions is not allowed either (it is considered a syntax error) so your interpreter will not need to account for these.\n\n## Kata in this Series\n\n1. [RoboScript #1 - Implement Syntax Highlighting](https://www.codewars.com/kata/roboscript-number-1-implement-syntax-highlighting)\n2. [RoboScript #2 - Implement the RS1 Specification](https://www.codewars.com/kata/roboscript-number-2-implement-the-rs1-specification)\n3. [RoboScript #3 - Implement the RS2 Specification](https://www.codewars.com/kata/58738d518ec3b4bf95000192)\n4. **RoboScript #4 - RS3 Patterns to the Rescue**",
  "totalAttempts": 42,
  "totalCompleted": 4,
  "totalStars": 1,
  "voteScore": 9,
  "tags": [
    "Algorithms",
    "Interpreters",
    "Logic",
    "Functional Programming",
    "Declarative Programming",
    "Programming Paradigms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}
